use bytes::Bytes;
use clap::Parser;
use core::fmt::Debug;
use futures::StreamExt;
use futures::{future, prelude::*};
use serde::{de::DeserializeOwned, Deserialize, Serialize};
use std::{
    any::{Any, TypeId},
    collections::HashMap,
    hash::{DefaultHasher, Hash, Hasher},
};
use tarpc::server::incoming::Incoming;
use tarpc::server::{self, Channel};
use tarpc::tokio_serde::formats::Json;
use tarpc::{client, context};

#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq, Serialize, Deserialize)]
struct PortableTypeId {
    type_id_hash: u64,
}

impl From<TypeId> for PortableTypeId {
    fn from(type_id: TypeId) -> Self {
        let mut s = DefaultHasher::new();
        type_id.hash(&mut s);
        Self {
            type_id_hash: s.finish(),
        }
    }
}

trait PortableData: Serialize + DeserializeOwned + Debug {}

impl<T> PortableData for T where T: Serialize + DeserializeOwned + Debug {}

#[derive(Default, Clone)]
struct PortableDataRegistry {
    coders: HashMap<PortableTypeId, fn(&dyn Any) -> Bytes>,
    decoders: HashMap<PortableTypeId, fn(&Bytes) -> Box<dyn Any>>,
    debuggers: HashMap<PortableTypeId, fn(&dyn Any) -> String>,
}

impl PortableDataRegistry {
    fn new() -> Self {
        Self {
            coders: HashMap::new(),
            decoders: HashMap::new(),
            debuggers: HashMap::new(),
        }
    }

    fn register<T: PortableData + 'static>(&mut self) {
        let type_id = TypeId::of::<T>();
        self.coders.insert(type_id.into(), |val: &dyn Any| {
            let val = val.downcast_ref::<T>().unwrap();
            serde_json::to_vec(val).unwrap().into()
        });
        self.decoders.insert(type_id.into(), |data: &Bytes| {
            let val: T = serde_json::from_slice(&data).unwrap();
            Box::new(val)
        });
        self.debuggers.insert(type_id.into(), |val: &dyn Any| {
            let val = val.downcast_ref::<T>().unwrap();
            format!("{:?}", val)
        });
    }

    fn encode(&self, data: &dyn Any) -> Bytes {
        let coder = self.coders.get(&data.type_id().into()).unwrap();
        coder(data)
    }

    fn decode(&self, type_id: PortableTypeId, data: &Bytes) -> Box<dyn Any> {
        let decoder = self.decoders.get(&type_id).unwrap();
        decoder(data)
    }

    fn debug(&self, data: &dyn Any) -> String {
        let debugger = self.debuggers.get(&data.type_id().into()).unwrap();
        debugger(data)
    }
}

#[tarpc::service]
trait PortableDataWorker {
    async fn debug(type_id: PortableTypeId, data: Vec<u8>) -> String;
}

#[derive(Clone)]
struct PortableDataServer {
    registry: PortableDataRegistry,
}

impl PortableDataWorker for PortableDataServer {
    async fn debug(
        self,
        _context: ::tarpc::context::Context,
        type_id: PortableTypeId,
        data: Vec<u8>,
    ) -> String {
        let bytes: Bytes = data.into();
        let data = self.registry.decode(type_id, &bytes);
        let debug_str = self.registry.debug(&*data);
        println!("Worker: {:?} -> {}", bytes, debug_str);
        debug_str
    }
}

fn create_registry() -> PortableDataRegistry {
    let mut registry = PortableDataRegistry::new();
    registry.register::<i32>();
    registry.register::<String>();
    registry
}

async fn spawn(fut: impl Future<Output = ()> + Send + 'static) {
    tokio::spawn(fut);
}

async fn run_server() -> anyhow::Result<()> {
    let server_addr = ("0.0.0.0", 50051);
    println!("Running server: {:?}", server_addr);
    let mut listener = tarpc::serde_transport::tcp::listen(server_addr, Json::default).await?;

    listener.config_mut().max_frame_length(usize::MAX);

    listener
        .filter_map(|r| future::ready(r.ok()))
        .map(server::BaseChannel::with_defaults)
        // limit channels to 1 per IP
        .max_channels_per_key(1, |t| t.as_ref().peer_addr().unwrap().ip())
        // serve is generated by the service attribute
        .map(|channel| {
            let registry = create_registry();
            let pdserver = PortableDataServer { registry };
            channel.execute(pdserver.serve()).for_each(spawn)
        })
        .buffer_unordered(16)
        .for_each(|_| async {})
        .await;

    Ok(())
}

async fn run_client() -> anyhow::Result<()> {
    let server_addr = ("127.0.0.1", 50051);
    println!("Running client: {:?}", server_addr);

    let mut transport = tarpc::serde_transport::tcp::connect(server_addr, Json::default);
    transport.config_mut().max_frame_length(usize::MAX);

    let client = PortableDataWorkerClient::new(client::Config::default(), transport.await?).spawn();
    let registry = create_registry();

    let data = 42;
    println!("Client: {:?} ->", data);
    let res = client
        .debug(
            context::current(),
            data.type_id().into(),
            registry.encode(&data).into(),
        )
        .await?;
    println!("Client: {} <-", res);

    let data = "hello portable data".to_string();
    println!("Client: {:?} ->", data);
    let res = client
        .debug(
            context::current(),
            data.type_id().into(),
            registry.encode(&data).into(),
        )
        .await?;
    println!("Client: {} <-", res);

    Ok(())
}

// async fn remote_debug<T: Serialize + 'static>(
//     data: T,
//     client: &PortableDataWorkerClient,
// ) -> impl Future<Output = Result<String, RpcError>> {
//     client.debug(
//         context::current(),
//         data.type_id().into(),
//         serde_json::to_vec(&data).unwrap(),
//     )
// }

#[derive(clap::Parser)]
struct Args {
    #[clap(short, long, default_value_t = false)]
    server: bool,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let args = Args::parse();

    if args.server {
        run_server().await?;
    } else {
        run_client().await?;
    }

    Ok(())
}
